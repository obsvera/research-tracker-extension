// WebExtension Browser API Polyfill
// Provides cross-browser compatibility for Firefox, Chrome, Edge, Opera, Brave, and Safari
// This is a lightweight version focused on the APIs used by this extension

(function (globalThis) {
  'use strict';

  // If browser API already exists (Firefox), we're done
  if (typeof globalThis.browser !== 'undefined' && globalThis.browser.runtime) {
    return;
  }

  // If chrome API doesn't exist either, bail
  if (typeof globalThis.chrome === 'undefined') {
    return;
  }

  // Wrap chrome API to return promises (chrome uses callbacks)
  const wrapAPI = (target, path = []) => {
    return new Proxy(target || {}, {
      get(obj, prop) {
        const value = obj[prop];

        if (value === undefined) {
          return undefined;
        }

        const fullPath = [...path, prop];

        // If it's a function, wrap it to return a promise
        if (typeof value === 'function') {
          return function (...args) {
            // Check if this is a callback-based API by looking at common patterns
            const hasCallback = args.length > 0 && typeof args[args.length - 1] === 'function';

            // Some APIs don't use callbacks and return values directly
            const syncMethods = [
              'getURL', 'getManifest', 'connect', 'sendMessage', 'sendNativeMessage',
              'create', 'remove', 'query', 'update', 'reload', 'sendMessage'
            ];

            // Methods that have different behavior
            if (fullPath.includes('runtime') && prop === 'onMessage') {
              // Special handling for onMessage - it doesn't need Promise wrapping
              return value.bind(obj);
            }

            if (fullPath.includes('storage') && (prop === 'get' || prop === 'set' || prop === 'remove' || prop === 'clear')) {
              // Storage APIs need promise wrapping
              return new Promise((resolve, reject) => {
                value.call(obj, ...args, (result) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError.message));
                  } else {
                    resolve(result);
                  }
                });
              });
            }

            if (fullPath.includes('tabs') && (prop === 'query' || prop === 'sendMessage' || prop === 'create' || prop === 'update')) {
              // Tabs APIs need promise wrapping
              return new Promise((resolve, reject) => {
                value.call(obj, ...args, (result) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError.message));
                  } else {
                    resolve(result);
                  }
                });
              });
            }

            if (fullPath.includes('downloads') && prop === 'download') {
              // Downloads API needs promise wrapping
              return new Promise((resolve, reject) => {
                value.call(obj, ...args, (downloadId) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError.message));
                  } else {
                    resolve(downloadId);
                  }
                });
              });
            }

            if (fullPath.includes('contextMenus') && (prop === 'create' || prop === 'update' || prop === 'remove')) {
              // Context menus - create doesn't use callback in Chrome but we'll handle it
              try {
                const result = value.call(obj, ...args);
                return Promise.resolve(result);
              } catch (err) {
                return Promise.reject(err);
              }
            }

            if (fullPath.includes('notifications') && prop === 'create') {
              // Notifications API
              return new Promise((resolve, reject) => {
                value.call(obj, ...args, (notificationId) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError.message));
                  } else {
                    resolve(notificationId);
                  }
                });
              });
            }

            // For everything else, try to detect if it needs a callback
            if (!hasCallback && args.length > 0 && typeof obj[prop] === 'function') {
              return new Promise((resolve, reject) => {
                try {
                  value.call(obj, ...args, (result) => {
                    if (chrome.runtime.lastError) {
                      reject(new Error(chrome.runtime.lastError.message));
                    } else {
                      resolve(result);
                    }
                  });
                } catch (err) {
                  reject(err);
                }
              });
            }

            // Default: just call the function
            return value.apply(obj, args);
          };
        }

        // If it's an object, recursively wrap it
        if (typeof value === 'object' && value !== null) {
          return wrapAPI(value, fullPath);
        }

        // Otherwise return the value as-is
        return value;
      }
    });
  };

  // Create browser namespace with wrapped chrome API
  const browserAPI = {
    runtime: wrapAPI(chrome.runtime, ['runtime']),
    storage: wrapAPI(chrome.storage, ['storage']),
    tabs: wrapAPI(chrome.tabs, ['tabs']),
    contextMenus: wrapAPI(chrome.contextMenus, ['contextMenus']),
    downloads: wrapAPI(chrome.downloads, ['downloads']),
    notifications: wrapAPI(chrome.notifications, ['notifications']),
    webRequest: wrapAPI(chrome.webRequest, ['webRequest']),
    webNavigation: wrapAPI(chrome.webNavigation, ['webNavigation']),
    cookies: wrapAPI(chrome.cookies, ['cookies']),
    windows: wrapAPI(chrome.windows, ['windows']),
    extension: wrapAPI(chrome.extension, ['extension']),
    i18n: wrapAPI(chrome.i18n, ['i18n']),
    identity: wrapAPI(chrome.identity, ['identity']),
    permissions: wrapAPI(chrome.permissions, ['permissions']),
    privacy: wrapAPI(chrome.privacy, ['privacy']),
    management: wrapAPI(chrome.management, ['management']),
    history: wrapAPI(chrome.history, ['history']),
    bookmarks: wrapAPI(chrome.bookmarks, ['bookmarks']),
    alarms: wrapAPI(chrome.alarms, ['alarms']),
    idle: wrapAPI(chrome.idle, ['idle']),

    // Manifest v3 specific - action replaces browserAction
    action: wrapAPI(chrome.action || chrome.browserAction, ['action']),
    // For backwards compatibility
    browserAction: wrapAPI(chrome.browserAction || chrome.action, ['browserAction'])
  };

  // Add scripting API for Manifest v3
  if (chrome.scripting) {
    browserAPI.scripting = wrapAPI(chrome.scripting, ['scripting']);
  }

  // Expose as global
  globalThis.browser = browserAPI;

  // Also make it available for service worker imports
  if (typeof self !== 'undefined') {
    self.browser = browserAPI;
  }

})(typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : this);
